import { H as HighlighterGeneric, a as HighlighterCoreOptions, B as BundledHighlighterOptions, L as LanguageInput, T as ThemeInput, C as CodeToHastOptions, R as Root, b as RequireKeys, c as CodeToThemedTokensOptions, d as ThemedToken, e as CodeToTokensWithThemesOptions, f as ThemedTokenWithVariants, M as MaybeArray, E as Element, S as ShikiInternal, g as ThemeRegistrationResolved, h as ShikijiTransformerContextCommon, i as ThemeRegistrationAny } from './chunk-types.mjs';
export { A as AnsiLanguage, m as Awaitable, Y as BundledLanguageInfo, Z as BundledThemeInfo, w as CodeOptionsMeta, u as CodeOptionsMultipleThemes, t as CodeOptionsSingleTheme, v as CodeOptionsThemes, s as CodeToHastOptionsCommon, W as DynamicImportLanguageRegistration, X as DynamicImportThemeRegistration, F as FontStyle, I as Grammar, N as HtmlRendererOptions, K as HtmlRendererOptionsCommon, I as IGrammar, j as IRawGrammar, r as LanguageRegistration, n as MaybeGetter, o as MaybeModule, P as PlainTextLanguage, j as RawGrammar, q as ResolveBundleKey, J as ShikijiTransformer, G as ShikijiTransformerContext, D as ShikijiTransformerContextMeta, k as SpecialLanguage, p as StringLiteralUnion, z as ThemeRegistration, y as ThemeRegistrationRaw, Q as ThemedTokenExplanation, O as ThemedTokenScopeExplanation, U as TokenBase, V as TokenStyles, x as TransformerOptions, l as loadWasm } from './chunk-types.mjs';

type HighlighterCore = HighlighterGeneric<never, never>;
declare function getHighlighterCore(options?: HighlighterCoreOptions): Promise<HighlighterCore>;

type GetHighlighterFactory<L extends string, T extends string> = (options?: BundledHighlighterOptions<L, T>) => Promise<HighlighterGeneric<L, T>>;
/**
 * Create a `getHighlighter` function with bundled themes and languages.
 *
 * @param bundledLanguages
 * @param bundledThemes
 * @param ladWasm
 */
declare function createdBundledHighlighter<BundledLangs extends string, BundledThemes extends string>(bundledLanguages: Record<BundledLangs, LanguageInput>, bundledThemes: Record<BundledThemes, ThemeInput>, ladWasm: HighlighterCoreOptions['loadWasm']): GetHighlighterFactory<BundledLangs, BundledThemes>;
declare function createSingletonShorthands<L extends string, T extends string>(getHighlighter: GetHighlighterFactory<L, T>): {
    getSingletonHighlighter: () => Promise<HighlighterGeneric<L, T>>;
    codeToHtml: (code: string, options: CodeToHastOptions<L, T>) => Promise<string>;
    codeToHast: (code: string, options: CodeToHastOptions<L, T>) => Promise<Root>;
    codeToThemedTokens: (code: string, options: RequireKeys<CodeToThemedTokensOptions<L, T>, 'theme' | 'lang'>) => Promise<ThemedToken[][]>;
    codeToTokensWithThemes: (code: string, options: RequireKeys<CodeToTokensWithThemesOptions<L, T>, 'themes' | 'lang'>) => Promise<ThemedTokenWithVariants[][]>;
};

declare function isPlaintext(lang: string | null | undefined): boolean;
declare function toArray<T>(x: MaybeArray<T>): T[];
declare function isSpecialLang(lang: string): boolean;
declare function addClassToHast(node: Element, className: string | string[]): void;

/**
 * Get the minimal shiki context for rendering.
 */
declare function getShikiInternal(options?: HighlighterCoreOptions): Promise<ShikiInternal>;
/**
 * @deprecated Use `getShikiInternal` instead.
 */
declare const getShikiContext: typeof getShikiInternal;

declare function codeToThemedTokens(internal: ShikiInternal, code: string, options?: CodeToThemedTokensOptions): ThemedToken[][];

declare function tokenizeAnsiWithTheme(theme: ThemeRegistrationResolved, fileContents: string): ThemedToken[][];

declare function codeToHast(internal: ShikiInternal, code: string, options: CodeToHastOptions, transformerContext?: ShikijiTransformerContextCommon): Root;

/**
 * Get highlighted code in HTML.
 */
declare function codeToHtml(internal: ShikiInternal, code: string, options: CodeToHastOptions): string;

/**
 * Get tokens with multiple themes
 */
declare function codeToTokensWithThemes(internal: ShikiInternal, code: string, options: CodeToTokensWithThemesOptions): ThemedTokenWithVariants[][];

/**
 * Normalize a textmate theme to shiki theme
 */
declare function normalizeTheme(rawTheme: ThemeRegistrationAny): ThemeRegistrationResolved;
/**
 * @deprecated Use `normalizeTheme` instead.
 */
declare const toShikiTheme: typeof normalizeTheme;

export { BundledHighlighterOptions, CodeToHastOptions, CodeToThemedTokensOptions, CodeToTokensWithThemesOptions, type GetHighlighterFactory, type HighlighterCore, HighlighterCoreOptions, HighlighterGeneric, LanguageInput, MaybeArray, RequireKeys, ShikiInternal, ShikijiTransformerContextCommon, ThemeInput, ThemeRegistrationAny, ThemeRegistrationResolved, ThemedToken, ThemedTokenWithVariants, addClassToHast, codeToHast, codeToHtml, codeToThemedTokens, codeToTokensWithThemes, createSingletonShorthands, createdBundledHighlighter, getHighlighterCore, getShikiContext, getShikiInternal, isPlaintext, isSpecialLang, normalizeTheme, toArray, toShikiTheme, tokenizeAnsiWithTheme };
