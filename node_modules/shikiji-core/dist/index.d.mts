import { H as HighlighterGeneric, a as HighlighterCoreOptions, B as BundledHighlighterOptions, L as LanguageInput, T as ThemeInput, C as CodeToHastOptions, R as Root, b as RequireKeys, c as CodeToThemedTokensOptions, d as ThemedToken, e as CodeToTokensWithThemesOptions, f as ThemedTokenWithVariants, M as MaybeArray, E as Element, S as ShikiInternal, g as ThemeRegistration, h as ShikijiTransformerContextCommon, i as ThemeRegistrationRaw } from './chunk-types.mjs';
export { A as AnsiLanguage, m as Awaitable, W as BundledLanguageInfo, X as BundledThemeInfo, w as CodeOptionsMeta, u as CodeOptionsMultipleThemes, t as CodeOptionsSingleTheme, v as CodeOptionsThemes, s as CodeToHastOptionsCommon, U as DynamicImportLanguageRegistration, V as DynamicImportThemeRegistration, F as FontStyle, I as Grammar, J as HtmlRendererOptions, G as HtmlRendererOptionsCommon, I as IGrammar, j as IRawGrammar, r as LanguageRegistration, n as MaybeGetter, o as MaybeModule, P as PlainTextLanguage, j as RawGrammar, q as ResolveBundleKey, D as ShikijiTransformer, z as ShikijiTransformerContext, y as ShikijiTransformerContextMeta, k as SpecialLanguage, p as StringLiteralUnion, N as ThemedTokenExplanation, K as ThemedTokenScopeExplanation, O as TokenBase, Q as TokenStyles, x as TransformerOptions, l as loadWasm } from './chunk-types.mjs';

type HighlighterCore = HighlighterGeneric<never, never>;
declare function getHighlighterCore(options?: HighlighterCoreOptions): Promise<HighlighterCore>;

type GetHighlighterFactory<L extends string, T extends string> = (options?: BundledHighlighterOptions<L, T>) => Promise<HighlighterGeneric<L, T>>;
/**
 * Create a `getHighlighter` function with bundled themes and languages.
 *
 * @param bundledLanguages
 * @param bundledThemes
 * @param ladWasm
 */
declare function createdBundledHighlighter<BundledLangs extends string, BundledThemes extends string>(bundledLanguages: Record<BundledLangs, LanguageInput>, bundledThemes: Record<BundledThemes, ThemeInput>, ladWasm: HighlighterCoreOptions['loadWasm']): GetHighlighterFactory<BundledLangs, BundledThemes>;
declare function createSingletonShorthands<L extends string, T extends string>(getHighlighter: GetHighlighterFactory<L, T>): {
    getSingletonHighlighter: () => Promise<HighlighterGeneric<L, T>>;
    codeToHtml: (code: string, options: CodeToHastOptions<L, T>) => Promise<string>;
    codeToHast: (code: string, options: CodeToHastOptions<L, T>) => Promise<Root>;
    codeToThemedTokens: (code: string, options: RequireKeys<CodeToThemedTokensOptions<L, T>, 'theme' | 'lang'>) => Promise<ThemedToken[][]>;
    codeToTokensWithThemes: (code: string, options: RequireKeys<CodeToTokensWithThemesOptions<L, T>, 'themes' | 'lang'>) => Promise<ThemedTokenWithVariants[][]>;
};

declare function isPlaintext(lang: string | null | undefined): boolean;
declare function toArray<T>(x: MaybeArray<T>): T[];
declare function isSpecialLang(lang: string): boolean;
declare function addClassToHast(node: Element, className: string | string[]): void;

/**
 * Get the minimal shiki context for rendering.
 */
declare function getShikiInternal(options?: HighlighterCoreOptions): Promise<ShikiInternal>;
/**
 * @deprecated Use `getShikiInternal` instead.
 */
declare const getShikiContext: typeof getShikiInternal;

declare function codeToThemedTokens(internal: ShikiInternal, code: string, options?: CodeToThemedTokensOptions): ThemedToken[][];

declare function tokenizeAnsiWithTheme(theme: ThemeRegistration, fileContents: string): ThemedToken[][];

declare function codeToHast(internal: ShikiInternal, code: string, options: CodeToHastOptions, transformerContext?: ShikijiTransformerContextCommon): Root;

/**
 * Get highlighted code in HTML.
 */
declare function codeToHtml(internal: ShikiInternal, code: string, options: CodeToHastOptions): string;

/**
 * Get tokens with multiple themes
 */
declare function codeToTokensWithThemes(internal: ShikiInternal, code: string, options: CodeToTokensWithThemesOptions): ThemedTokenWithVariants[][];

declare function toShikiTheme(rawTheme: ThemeRegistrationRaw | ThemeRegistration): ThemeRegistration;

export { BundledHighlighterOptions, CodeToHastOptions, CodeToThemedTokensOptions, CodeToTokensWithThemesOptions, type GetHighlighterFactory, type HighlighterCore, HighlighterCoreOptions, HighlighterGeneric, LanguageInput, MaybeArray, RequireKeys, ShikiInternal, ShikijiTransformerContextCommon, ThemeInput, ThemeRegistration, ThemeRegistrationRaw, ThemedToken, ThemedTokenWithVariants, addClassToHast, codeToHast, codeToHtml, codeToThemedTokens, codeToTokensWithThemes, createSingletonShorthands, createdBundledHighlighter, getHighlighterCore, getShikiContext, getShikiInternal, isPlaintext, isSpecialLang, toArray, toShikiTheme, tokenizeAnsiWithTheme };
